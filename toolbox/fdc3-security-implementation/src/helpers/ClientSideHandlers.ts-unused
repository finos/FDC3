import { AppIdentifier, ContextHandler, ContextMetadata, DesktopAgent, IntentHandler, IntentResult } from "@finos/fdc3-standard";
import { Context } from "@finos/fdc3-context"
import { BroadcastRequest, RaiseIntentRequest } from "@finos/fdc3-schema/dist/generated/api/BrowserTypes";
import { v4 as uuidv4 } from 'uuid';
import { Messaging } from "@finos/fdc3-agent-proxy";
import { RaiseIntentResultResponse } from "@finos/fdc3-schema/generated/api/BrowserTypes";

interface WebSocketMessage {
    requestId: string;
    type: string;
    payload: any;
}

interface PendingRequest {
    resolve: (value: any) => void;
    reject: (error: Error) => void;
    timeout: NodeJS.Timeout;
}

/**
 * This class provides a set of helpers for clients to use
 * to move processing of secure FDC3 intents and contexts to the 
 * server-side using WebSocket communication.
 */
export class ClientSideHandlers {

    private desktopAgent: DesktopAgent;
    private messaging: Messaging;
    private timeoutMs: number = 10000;

    constructor(desktopAgent: DesktopAgent, messaging: Messaging) {
        this.desktopAgent = desktopAgent;
        this.messaging = messaging;
    }

    async createRemoteIntentHandler(intent: string): Promise<IntentHandler> {
        const appInfo = await this.desktopAgent.getInfo();
        const app = appInfo.appMetadata;

        return async (context: Context, metadata: ContextMetadata | undefined): Promise<IntentResult> => {
            try {
                const response: RaiseIntentResultResponse = await this.messaging.exchange(
                    this.raiseIntentRequest(app, intent, context, metadata),
                    'raiseIntentResultResponse',
                    this.timeoutMs
                );

                if (response) {
                    switch (response.payload.type) {
                        case 'user':
                            return response as RaiseIntentRequest;
                        case 'private':
                            return response as BroadcastRequest;
                        case 'app':
                            return response as IntentResult;
                        default:
                            return response as IntentResult;
                    }
                } else {
                    return null as any;
                }
            } catch (error) {
                console.error('Failed to handle remote intent:', error);
                throw error;
            }
        };
    }

    async createRemoteContextHandler(channelId: string): Promise<ContextHandler> {
        return async (context: Context, metadata: ContextMetadata | undefined): Promise<void> => {
            try {
                await this.messaging.exchange(
                    this.broadcastRequest(channelId, context, metadata),
                    'broadcastResponse',
                    this.timeoutMs
                );
            } catch (error) {
                console.error('Failed to handle remote context:', error);
                throw new Error(`Failed to broadcast context: ${error}`);
            }
        };
    }

    private broadcastRequest(channelId: string, context: Context, metadata: ContextMetadata | undefined): BroadcastRequest {
        return {
            type: 'broadcastRequest',
            meta: {
                requestUuid: uuidv4(),
                timestamp: new Date()
            },
            payload: {
                channelId,
                context,
                // metadata
            }
        };
    }

    private raiseIntentRequest(app: AppIdentifier, intent: string, context: Context, metadata: ContextMetadata | undefined): RaiseIntentRequest {
        return {
            type: 'raiseIntentRequest',
            meta: {
                requestUuid: uuidv4(),
                timestamp: new Date()
            },
            payload: {
                app,
                context,
                intent
                //metadata
            }
        };
    }
}