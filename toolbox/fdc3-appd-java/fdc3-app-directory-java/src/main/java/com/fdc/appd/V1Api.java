/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech) (7.8.0).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
package com.fdc.appd;

import com.fdc.appd.model.ApplicationSearchResponseV1;
import com.fdc.appd.model.ApplicationV1;
import com.fdc.appd.model.ErrorDTO;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.enums.ParameterIn;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.annotation.Generated;
import jakarta.validation.Valid;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;

@Generated(value = "org.openapitools.codegen.languages.SpringCodegen", date = "2024-11-10T19:40:14.622447+05:30[Asia/Kolkata]", comments = "Generator version: 7.8.0")
@Validated
@Tag(name = "Application", description = "the Application API")
public interface V1Api {

    default V1ApiDelegate getDelegate() {
        return new V1ApiDelegate() {};
    }

    /**
     * GET /v1/apps/{appId} : Retrieve an application definition
     *
     * @param appId  (required)
     * @return OK (status code 200)
     *         or Bad request. (status code 400)
     *         or Forbidden: Certificate authentication is not allowed for the requested user. (status code 403)
     *         or Server error, see response body for further details. (status code 500)
     * @deprecated
     */
    @Deprecated
    @Operation(
        operationId = "v1AppsAppIdGet",
        summary = "Retrieve an application definition",
        deprecated = true,
        tags = { "Application" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ApplicationV1.class)),
                @Content(mediaType = "*/*", schema = @Schema(implementation = ApplicationV1.class))
            }),
            @ApiResponse(responseCode = "400", description = "Bad request.", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorDTO.class)),
                @Content(mediaType = "*/*", schema = @Schema(implementation = ErrorDTO.class))
            }),
            @ApiResponse(responseCode = "403", description = "Forbidden: Certificate authentication is not allowed for the requested user.", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorDTO.class)),
                @Content(mediaType = "*/*", schema = @Schema(implementation = ErrorDTO.class))
            }),
            @ApiResponse(responseCode = "500", description = "Server error, see response body for further details.", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorDTO.class)),
                @Content(mediaType = "*/*", schema = @Schema(implementation = ErrorDTO.class))
            })
        },
        security = {
            @SecurityRequirement(name = "bearerAuth")
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = "/v1/apps/{appId}",
        produces = { "application/json", "*/*" }
    )
    
    default ResponseEntity<ApplicationV1> v1AppsAppIdGet(
        @Parameter(name = "appId", description = "", required = true, in = ParameterIn.PATH) @PathVariable("appId") String appId
    ) {
        return getDelegate().v1AppsAppIdGet(appId);
    }


    /**
     * POST /v1/apps : Create a new application definition
     *
     * @param applicationV1  (required)
     * @return OK (status code 200)
     *         or Bad request. (status code 400)
     *         or Forbidden: Certificate authentication is not allowed for the requested user. (status code 403)
     *         or Server error, see response body for further details. (status code 500)
     * @deprecated
     */
    @Deprecated
    @Operation(
        operationId = "v1AppsPost",
        summary = "Create a new application definition",
        deprecated = true,
        tags = { "Application" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ApplicationSearchResponseV1.class))
            }),
            @ApiResponse(responseCode = "400", description = "Bad request.", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorDTO.class))
            }),
            @ApiResponse(responseCode = "403", description = "Forbidden: Certificate authentication is not allowed for the requested user.", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorDTO.class))
            }),
            @ApiResponse(responseCode = "500", description = "Server error, see response body for further details.", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorDTO.class))
            })
        },
        security = {
            @SecurityRequirement(name = "bearerAuth")
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = "/v1/apps",
        produces = { "application/json" },
        consumes = { "application/json" }
    )
    
    default ResponseEntity<ApplicationSearchResponseV1> v1AppsPost(
        @Parameter(name = "ApplicationV1", description = "", required = true) @Valid @RequestBody ApplicationV1 applicationV1
    ) {
        return getDelegate().v1AppsPost(applicationV1);
    }


    /**
     * GET /v1/apps/search : Retrieve a list of applications based on parameters provided.  Depending on implementation, parameter values should self describe search format and type (e.g. Regex)
     *
     * @param appId The unique application identifier located within a specific application directory instance.  (optional)
     * @param name The name of the application. The name should be unique within an FDC3 App Directory instance. The exception to the uniqueness constraint is that an App Directory can hold definitions for multiple versions of the same app. The same appName could occur in other directories. We are not currently specifying app name conventions in the document.  (optional)
     * @param version Version of the application. This allows multiple app versions to be defined using the same app name. This can be a triplet but can also include things like 1.2.5 (BETA) (optional)
     * @param title Optional title for the application, if missing use appName, typically used in a launcher UI. (optional)
     * @param tooltip Optional tooltip description e.g. for a launcher (optional)
     * @param description Description of the application. This will typically be a 1-2 paragraph style blurb about the application. Allow mark up language (optional)
     * @param intentName name of intent (optional)
     * @param intentDisplayName displayName of intent (optional)
     * @param intentContext search contexts list (optional)
     * @return OK (status code 200)
     *         or Bad request. (status code 400)
     *         or Forbidden: Certificate authentication is not allowed for the requested user. (status code 403)
     *         or Server error, see response body for further details. (status code 500)
     * @deprecated
     */
    @Deprecated
    @Operation(
        operationId = "v1AppsSearchGet",
        summary = "Retrieve a list of applications based on parameters provided.  Depending on implementation, parameter values should self describe search format and type (e.g. Regex)",
        deprecated = true,
        tags = { "Application" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ApplicationSearchResponseV1.class))
            }),
            @ApiResponse(responseCode = "400", description = "Bad request.", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorDTO.class))
            }),
            @ApiResponse(responseCode = "403", description = "Forbidden: Certificate authentication is not allowed for the requested user.", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorDTO.class))
            }),
            @ApiResponse(responseCode = "500", description = "Server error, see response body for further details.", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorDTO.class))
            })
        },
        security = {
            @SecurityRequirement(name = "bearerAuth")
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = "/v1/apps/search",
        produces = { "application/json" }
    )
    
    default ResponseEntity<ApplicationSearchResponseV1> v1AppsSearchGet(
        @Parameter(name = "appId", description = "The unique application identifier located within a specific application directory instance. ", in = ParameterIn.QUERY) @Valid @RequestParam(value = "appId", required = false) String appId,
        @Parameter(name = "name", description = "The name of the application. The name should be unique within an FDC3 App Directory instance. The exception to the uniqueness constraint is that an App Directory can hold definitions for multiple versions of the same app. The same appName could occur in other directories. We are not currently specifying app name conventions in the document. ", in = ParameterIn.QUERY) @Valid @RequestParam(value = "name", required = false) String name,
        @Parameter(name = "version", description = "Version of the application. This allows multiple app versions to be defined using the same app name. This can be a triplet but can also include things like 1.2.5 (BETA)", in = ParameterIn.QUERY) @Valid @RequestParam(value = "version", required = false) String version,
        @Parameter(name = "title", description = "Optional title for the application, if missing use appName, typically used in a launcher UI.", in = ParameterIn.QUERY) @Valid @RequestParam(value = "title", required = false) String title,
        @Parameter(name = "tooltip", description = "Optional tooltip description e.g. for a launcher", in = ParameterIn.QUERY) @Valid @RequestParam(value = "tooltip", required = false) String tooltip,
        @Parameter(name = "description", description = "Description of the application. This will typically be a 1-2 paragraph style blurb about the application. Allow mark up language", in = ParameterIn.QUERY) @Valid @RequestParam(value = "description", required = false) String description,
        @Parameter(name = "intent_name", description = "name of intent", in = ParameterIn.QUERY) @Valid @RequestParam(value = "intent_name", required = false) String intentName,
        @Parameter(name = "intent_displayName", description = "displayName of intent", in = ParameterIn.QUERY) @Valid @RequestParam(value = "intent_displayName", required = false) String intentDisplayName,
        @Parameter(name = "intent_context", description = "search contexts list", in = ParameterIn.QUERY) @Valid @RequestParam(value = "intent_context", required = false) String intentContext
    ) {
        return getDelegate().v1AppsSearchGet(appId, name, version, title, tooltip, description, intentName, intentDisplayName, intentContext);
    }

}
